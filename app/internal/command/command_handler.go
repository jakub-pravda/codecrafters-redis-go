package command

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/codecrafters-io/redis-starter-go/app/internal/keyvaluestore"
	"github.com/codecrafters-io/redis-starter-go/app/internal/respparser"
	"github.com/codecrafters-io/redis-starter-go/app/internal/streamstore"
	"github.com/codecrafters-io/redis-starter-go/app/internal/utils"
)

type CommandHandler[T any] interface {
	Process() (respparser.RespData, error)
}

func (c EchoCommand) Process() (respparser.RespData, error) {
	resp := respparser.BulkString{
		Value: c.Message,
	}
	return resp, nil
}

func (c PingCommand) Process() (respparser.RespData, error) {
	pong := respparser.SimpleString{
		Value: "PONG",
	}
	return pong, nil
}

func (c GetCommand) Process() (respparser.RespData, error) {
	get, found := keyvaluestore.Get(c.Key)
	var resp respparser.BulkString

	if found {
		resp = respparser.BulkString{
			Value: get.Value,
		}
	} else {
		resp = respparser.BulkString{
			Value:  get.Value,
			IsNull: true,
		}
	}
	return resp, nil
}

func (c SetCommand) Process() (respparser.RespData, error) {
	keyStoreValue := keyvaluestore.KeyStoreValue{
		InsertedDatetime: time.Now(),
	}

	expires := keyStoreValue.InsertedDatetime.Add(time.Duration(c.RecordExpirationMillis) * time.Millisecond)

	keyStoreValue.Key = c.Key
	keyStoreValue.Value = c.Value
	keyStoreValue.Expire = &expires

	keyvaluestore.Append(keyStoreValue)
	return okResponse, nil
}

func (c TypeCommand) Process() (respparser.RespData, error) {

	_, foundInKv := keyvaluestore.Get(c.Key)
	if foundInKv {
		resp := respparser.SimpleString{
			Value: "string",
		}
		return resp, nil
	}

	_, foundInStream := streamstore.GetTopItem(c.Key)
	if foundInStream {
		resp := respparser.SimpleString{
			Value: "stream",
		}
		return resp, nil
	}

	resp := respparser.SimpleString{
		Value: "none",
	}
	return resp, nil
}

func (c XAddCommand) Process() (respparser.RespData, error) {
	millisecondsTime := c.EntryId.MillisecondsTime
	sequenceNumber := c.EntryId.SequenceNumber

	topItem, topItemFound := streamstore.GetTopItem(c.StreamKey)

	if c.EntryId.AutoGenerated == FullyGeneratedEntryId {
		// autogenerated sequence number time
		millisecondsTime = time.Now().UnixMilli()
		utils.Log(fmt.Sprintf("(XADD cmd) Autogenerated time: %d)", millisecondsTime))
	}

	if c.EntryId.AutoGenerated == PartiallyGeneratedEntryId || c.EntryId.AutoGenerated == FullyGeneratedEntryId {
		// autogenerated sequence number
		if topItemFound && topItem.EntryIdMillisecondsTime == millisecondsTime {
			sequenceNumber = topItem.EntryIdSequenceNumber + 1
		} else if millisecondsTime == 0 {
			sequenceNumber = 1
		} else {
			sequenceNumber = 0
		}
		utils.Log(fmt.Sprintf("(XADD cmd) Autogenerated sequence number: %d)", sequenceNumber))
	}

	streamValue := streamstore.RedisStream{
		StreamKey:               c.StreamKey,
		EntryIdMillisecondsTime: millisecondsTime,
		EntryIdSequenceNumber:   sequenceNumber,
		StreamValues:            c.FieldValues,
		InsertedDatetime:        time.Now(),
	}

	if err := validateEntryId(streamValue, &topItem, topItemFound); err != nil {
		utils.Log(fmt.Sprintf("(XADD cmd) EntryId validation failed: %e)", err))
		return respparser.BulkString{}, err
	}

	streamstore.Append(streamValue)
	resp := respparser.BulkString{
		Value: fmt.Sprintf("%d-%d", millisecondsTime, sequenceNumber),
	}

	return resp, nil
}

func (c XRangeCommand) Process() (respparser.RespData, error) {
	items, found := streamstore.GetItems(c.StreamKey, c.StartEntryId.MillisecondsTime, c.EndEntryId.MillisecondsTime, c.StartEntryId.SequenceNumber, c.EndEntryId.SequenceNumber)
	if !found {
		// stream not found
		utils.Log(fmt.Sprintf("(XRangeCommand) Stream %s not found", c.StreamKey))
		return respparser.Array{}, nil
	}

	result := respparser.Array{}
	for _, i := range items {

		// id
		id := respparser.BulkString{
			Value: i.StreamId(),
		}
		// values
		values := respparser.Array{}
		for k, v := range i.StreamValues {
			bulkKey := respparser.BulkString{
				Value: k,
			}
			bulkValue := respparser.BulkString{
				Value: v,
			}
			values.Items = append(values.Items, bulkKey, bulkValue)
		}

		result.Items = append(result.Items, respparser.Array{Items: []respparser.RespData{id, values}})
	}

	return result, nil
}

func (c XReadCommand) Process() (respparser.RespData, error) {
	utils.Log("(XReadCommand) Processing XRead command")
	streams := []respparser.RespData{}

	for streamKey, entryId := range c.Streams.keysIds {

		// Create stream filter for this use case
		streamFilter := func(filter []streamstore.RedisStream) []streamstore.RedisStream {
			// XREAD is exclusive - command retrieves records with ID greater than the specified ID
			filtered := []streamstore.RedisStream{}

			for _, e := range filter {
				if e.EntryIdMillisecondsTime == entryId.MillisecondsTime && e.EntryIdSequenceNumber == entryId.SequenceNumber {
					// exclusive search
					continue
				} else if e.EntryIdMillisecondsTime >= entryId.MillisecondsTime && e.EntryIdSequenceNumber >= entryId.SequenceNumber {
					filtered = append(filtered, e)
				}
			}

			return filtered
		}

		result, found := streamstore.GetItemsByFilter(streamKey, streamFilter)

		if !found && c.IsBlocking {
			// blocking, wait for result
			utils.Log(fmt.Sprintf("(XReadCommand) Stream with key %s not found, waiting for %d milliseconds", streamKey, c.BlockMillis))
			ctx, _ := context.WithTimeout(context.Background(), time.Duration(c.BlockMillis)*time.Millisecond) // TODO cancel
			recChan := streamstore.GetItemsByFilterChan(streamKey, streamFilter, ctx)
			chanRes, chanOk := <-recChan
			if !chanOk {
				// remark: when timeout occurs, nil array is returned
				nilArray := respparser.Array{IsNull: true}
				return nilArray, nil
			} else {
				result = chanRes
				found = len(chanRes) > 0
			}
		}

		if !found {
			utils.Log(fmt.Sprintf("(XReadCommand) Stream with key %s not found", streamKey))
			continue
		}

		streamData := make([]respparser.RespData, 0)
		for _, redisStream := range result {
			streamData = append(streamData, redisStream.ToRespArray())
		}

		stream := respparser.Array{
			Items: []respparser.RespData{
				respparser.BulkString{Value: streamKey},
				respparser.Array{Items: streamData},
			},
		}
		utils.Log(fmt.Sprintf("(XReadCommand) Appending stream with stream key %s to result", streamKey))
		streams = append(streams, stream)
	}

	resultArray := respparser.Array{
		Items: streams,
	}

	utils.Log(fmt.Sprintf("(XReadCommand) Return %v", resultArray))
	return resultArray, nil
}

func validateEntryId(s streamstore.RedisStream, topItem *streamstore.RedisStream, topItemFound bool) error {
	if s.EntryIdMillisecondsTime == 0 && s.EntryIdSequenceNumber == 0 {
		return errors.New("ERR The ID specified in XADD must be greater than 0-0")
	}

	if topItemFound && (topItem.EntryIdMillisecondsTime > s.EntryIdMillisecondsTime) {
		return errors.New("ERR The ID specified in XADD is equal or smaller than the target stream top item")
	} else if topItemFound && (topItem.EntryIdMillisecondsTime == s.EntryIdMillisecondsTime && topItem.EntryIdSequenceNumber >= s.EntryIdSequenceNumber) {
		return errors.New("ERR The ID specified in XADD is equal or smaller than the target stream top item")
	} else {
		return nil
	}
}
