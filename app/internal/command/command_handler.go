package command

// TODO split by each command

import (
	"errors"
	"fmt"
	"time"

	"github.com/codecrafters-io/redis-starter-go/app/internal/respparser"
	"github.com/codecrafters-io/redis-starter-go/app/internal/store"
	"github.com/codecrafters-io/redis-starter-go/app/internal/streamstore"
	"github.com/codecrafters-io/redis-starter-go/app/internal/utils"
)

type CommandHandler[T any] interface {
	Process() (respparser.RespData, error)
}

func (c EchoCommand) Process() (respparser.RespData, error) {
	resp := respparser.BulkString{
		Value: c.Message,
	}
	return resp, nil
}

func (c PingCommand) Process() (respparser.RespData, error) {
	pong := respparser.SimpleString{
		Value: "PONG",
	}
	return pong, nil
}

func (c GetCommand) Process() (respparser.RespData, error) {
	get, found := store.Get(c.Key)
	var resp respparser.BulkString

	if found {
		resp = respparser.BulkString{
			Value: get.Value,
		}
	} else {
		resp = respparser.BulkString{
			Value:  get.Value,
			IsNull: true,
		}
	}
	return resp, nil
}

func (c SetCommand) Process() (respparser.RespData, error) {
	keyStoreValue := store.KeyStoreValue{
		InsertedDatetime: time.Now(),
	}

	expires := keyStoreValue.InsertedDatetime.Add(time.Duration(c.RecordExpirationMillis) * time.Millisecond)

	keyStoreValue.Key = c.Key
	keyStoreValue.Value = c.Value
	keyStoreValue.Expire = &expires

	store.Append(keyStoreValue)
	return okResponse, nil
}

func (c TypeCommand) Process() (respparser.RespData, error) {

	_, foundInKv := store.Get(c.Key)
	if foundInKv {
		resp := respparser.SimpleString{
			Value: "string",
		}
		return resp, nil
	}

	_, foundInStream := streamstore.GetTopItem(c.Key)
	if foundInStream {
		resp := respparser.SimpleString{
			Value: "stream",
		}
		return resp, nil
	}

	resp := respparser.SimpleString{
		Value: "none",
	}
	return resp, nil
}

func (c XAddCommand) Process() (respparser.RespData, error) {
	millisecondsTime := c.EntryId.MillisecondsTime
	sequenceNumber := c.EntryId.SequenceNumber

	topItem, topItemFound := streamstore.GetTopItem(c.StreamKey)

	if c.EntryId.AutoGenerated == FullyGeneratedEntryId {
		// autogenerated sequence number time
		millisecondsTime = time.Now().UnixMilli()
		utils.Log(fmt.Sprintf("(XADD cmd) Autogenerated time: %d)", millisecondsTime))
	}

	if c.EntryId.AutoGenerated == PartiallyGeneratedEntryId || c.EntryId.AutoGenerated == FullyGeneratedEntryId {
		// autogenerated sequence number
		if topItemFound && topItem.EntryIdMillisecondsTime == millisecondsTime {
			sequenceNumber = topItem.EntryIdSequenceNumber + 1
		} else if millisecondsTime == 0 {
			sequenceNumber = 1
		} else {
			sequenceNumber = 0
		}
		utils.Log(fmt.Sprintf("(XADD cmd) Autogenerated sequence number: %d)", sequenceNumber))
	}

	streamValue := streamstore.RedisStream{
		StreamKey:               c.StreamKey,
		EntryIdMillisecondsTime: millisecondsTime,
		EntryIdSequenceNumber:   sequenceNumber,
		StreamValues:            c.FieldValues,
		InsertedDatetime:        time.Now(),
	}

	if err := validateEntryId(streamValue, &topItem, topItemFound); err != nil {
		utils.Log(fmt.Sprintf("(XADD cmd) EntryId validation failed: %e)", err))
		return respparser.BulkString{}, err
	}

	storeChannel := streamstore.GetStreamStoreChannel()
	utils.Log(fmt.Sprintf("(XADD cmd) Sending record using channel: %v)", streamValue))
	storeChannel <- streamValue

	resp := respparser.BulkString{
		Value: fmt.Sprintf("%d-%d", millisecondsTime, sequenceNumber),
	}

	return resp, nil
}

func (c XRangeCommand) Process() (respparser.RespData, error) {
	items, found := streamstore.GetItems(c.StreamKey, c.StartEntryId.MillisecondsTime, c.EndEntryId.MillisecondsTime, c.StartEntryId.SequenceNumber, c.EndEntryId.SequenceNumber)
	if !found {
		// stream not found
		utils.Log(fmt.Sprintf("(XRangeCommand) Stream %s not found", c.StreamKey))
		return respparser.Array{}, nil
	}

	result := respparser.Array{}
	for _, i := range items {

		// id
		id := respparser.BulkString{
			Value: i.StreamId(),
		}
		// values
		values := respparser.Array{}
		for k, v := range i.StreamValues {
			bulkKey := respparser.BulkString{
				Value: k,
			}
			bulkValue := respparser.BulkString{
				Value: v,
			}
			values.Items = append(values.Items, bulkKey, bulkValue)
		}

		result.Items = append(result.Items, respparser.Array{Items: []respparser.RespData{id, values}})
	}

	return result, nil
}

func validateEntryId(s streamstore.RedisStream, topItem *streamstore.RedisStream, topItemFound bool) error {
	if s.EntryIdMillisecondsTime == 0 && s.EntryIdSequenceNumber == 0 {
		return errors.New("ERR The ID specified in XADD must be greater than 0-0")
	}

	if topItemFound && (topItem.EntryIdMillisecondsTime > s.EntryIdMillisecondsTime) {
		return errors.New("ERR The ID specified in XADD is equal or smaller than the target stream top item")
	} else if topItemFound && (topItem.EntryIdMillisecondsTime == s.EntryIdMillisecondsTime && topItem.EntryIdSequenceNumber >= s.EntryIdSequenceNumber) {
		return errors.New("ERR The ID specified in XADD is equal or smaller than the target stream top item")
	} else {
		return nil
	}
}
