package command

import (
	"maps"
	"math"
	"testing"
)

func sameXAddCommandResults(f *XAddCommand, s *XAddCommand) bool {
	// compare simple values
	if f.StreamKey != s.StreamKey ||
		f.EntryId.MillisecondsTime != s.EntryId.MillisecondsTime ||
		f.EntryId.SequenceNumber != s.EntryId.SequenceNumber ||
		f.EntryId.AutoGenerated != s.EntryId.AutoGenerated {
		return false
	}

	// compare maps
	return maps.Equal(f.FieldValues, s.FieldValues)
}

// TODO not needed compare directly
func sameXRangeCommandResults(f *XRangeCommand, s *XRangeCommand) bool {
	// compare simple values
	return f.StreamKey == s.StreamKey &&
		f.StartEntryId.MillisecondsTime == s.StartEntryId.MillisecondsTime &&
		f.StartEntryId.SequenceNumber == s.StartEntryId.SequenceNumber &&
		f.EndEntryId.MillisecondsTime == s.EndEntryId.MillisecondsTime &&
		f.EndEntryId.SequenceNumber == s.EndEntryId.SequenceNumber
}

func sameXReadCommandResults(f *XReadCommand, s *XReadCommand) bool {
	// compare simple values
	blocksEqual := f.BlockMillis == s.BlockMillis
	streamsEqual := true

	for n, _ := range f.Streams {
		fStream := f.Streams[n]
		sStream := s.Streams[n]

		if fStream.streamKey != sStream.streamKey || fStream.entryId != sStream.entryId {
			streamsEqual = false
			break
		}
	}

	return blocksEqual && streamsEqual
}

func TestParseXaddCommand(t *testing.T) {
	var tests = []struct {
		name  string
		input Command
		want  XAddCommand
	}{
		// simple XADD command
		{
			name: "XADD command should be parsed",
			input: Command{CommandType: "XADD", CommandValues: []string{
				"stream-key", "1-1", "foo", "bar",
			}},
			want: XAddCommand{
				StreamKey: "stream-key",
				EntryId: EntryId{
					MillisecondsTime: 1,
					SequenceNumber:   1,
				},
				FieldValues: map[string]string{"foo": "bar"},
			},
		},
		// XADD command - partially generated entry ID
		{
			name: "XADD command with partially generated entry ID should be parsed",
			input: Command{CommandType: "XADD", CommandValues: []string{
				"stream-key", "10-*", "foo", "bar",
			}},
			want: XAddCommand{
				StreamKey: "stream-key",
				EntryId: EntryId{
					MillisecondsTime: 10,
					AutoGenerated:    PartiallyGeneratedEntryId,
				},
				FieldValues: map[string]string{"foo": "bar"},
			},
		},
		// XADD command - fully generated entry ID
		{
			name: "XADD command with fully generated entry ID should be parsed",
			input: Command{CommandType: "XADD", CommandValues: []string{
				"stream-key", "*", "foo", "bar",
			}},
			want: XAddCommand{
				StreamKey:   "stream-key",
				FieldValues: map[string]string{"foo": "bar"},
				EntryId: EntryId{
					AutoGenerated: FullyGeneratedEntryId,
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ans, err := parseXAddCommand(&tt.input)
			if err != nil {
				t.Errorf("ERROR result expected, but err got: %s", err.Error())
			}

			if !sameXAddCommandResults(&ans, &tt.want) {
				t.Errorf("ERROR got %v, want %v", ans, tt.want)
			}
		})
	}
}

func TestParseXRangeCommand(t *testing.T) {
	var tests = []struct {
		name  string
		input Command
		want  XRangeCommand
	}{
		// XRANGE command
		{
			name: "XRANGE default sequence number",
			input: Command{CommandType: "XRANGE", CommandValues: []string{
				"stream-key", "1526985054069", "1526985054079",
			}},
			want: XRangeCommand{

				StreamKey: "stream-key",
				StartEntryId: EntryId{
					SequenceNumber:   0,
					MillisecondsTime: int64(1526985054069),
				},
				EndEntryId: EntryId{
					SequenceNumber:   0,
					MillisecondsTime: int64(1526985054079),
				},
			},
		},
		{
			name: "XRANGE start sequence number defined",
			input: Command{CommandType: "XRANGE", CommandValues: []string{
				"stream-key", "1526985054069-1", "1526985054079",
			}},
			want: XRangeCommand{

				StreamKey: "stream-key",
				StartEntryId: EntryId{
					SequenceNumber:   1,
					MillisecondsTime: int64(1526985054069),
				},
				EndEntryId: EntryId{
					SequenceNumber:   0,
					MillisecondsTime: int64(1526985054079),
				},
			},
		},
		{
			name: "XRANGE end sequence number defined",
			input: Command{CommandType: "XRANGE", CommandValues: []string{
				"stream-key", "1526985054069", "1526985054079-10",
			}},
			want: XRangeCommand{

				StreamKey: "stream-key",
				StartEntryId: EntryId{
					SequenceNumber:   0,
					MillisecondsTime: int64(1526985054069),
				},
				EndEntryId: EntryId{
					SequenceNumber:   10,
					MillisecondsTime: int64(1526985054079),
				},
			},
		},
		{
			name: "XRANGE sequence numbers defined",
			input: Command{CommandType: "XRANGE", CommandValues: []string{
				"stream-key", "1526985054069-10", "1526985054079-20",
			}},
			want: XRangeCommand{

				StreamKey: "stream-key",
				StartEntryId: EntryId{
					SequenceNumber:   10,
					MillisecondsTime: int64(1526985054069),
				},
				EndEntryId: EntryId{
					SequenceNumber:   20,
					MillisecondsTime: int64(1526985054079),
				},
			},
		},
		{
			name: "XRANGE start defined by - command",
			input: Command{CommandType: "XRANGE", CommandValues: []string{
				"stream-key", "-", "1526985054079-20",
			}},
			want: XRangeCommand{

				StreamKey: "stream-key",
				StartEntryId: EntryId{
					SequenceNumber:   0,
					MillisecondsTime: int64(0),
				},
				EndEntryId: EntryId{
					SequenceNumber:   20,
					MillisecondsTime: int64(1526985054079),
				},
			},
		},
		{
			name: "XRANGE end defined by + command",
			input: Command{CommandType: "XRANGE", CommandValues: []string{
				"stream-key", "1526985054079-1", "+",
			}},
			want: XRangeCommand{
				StreamKey: "stream-key",
				StartEntryId: EntryId{
					SequenceNumber:   1,
					MillisecondsTime: int64(1526985054079),
				},
				EndEntryId: EntryId{
					SequenceNumber:   math.MaxInt,
					MillisecondsTime: math.MaxInt64,
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ans, err := parseXRangeCommand(&tt.input)
			if err != nil {
				t.Errorf("ERROR result expected, but err got: %s", err.Error())
			}

			if !sameXRangeCommandResults(&ans, &tt.want) {
				t.Errorf("ERROR got %v, want %v", ans, tt.want)
			}
		})
	}
}

func TestParseXReadCommand(t *testing.T) {
	var tests = []struct {
		name  string
		input Command
		want  XReadCommand
	}{
		{
			name: "XREAD read with single stream",
			input: Command{CommandType: "XREAD", CommandValues: []string{
				"STREAMS", "stream-key", "1526985054069-1",
			}},
			want: XReadCommand{
				Streams: []XReadStream{
					XReadStream{
						streamKey: "stream-key",
						entryId: EntryId{
							MillisecondsTime: int64(1526985054069),
							SequenceNumber:   1,
						},
					},
				},
			},
		},
		{
			name: "XREAD read with multiple streams",
			input: Command{CommandType: "XREAD", CommandValues: []string{
				"STREAMS", "stream-key-1", "stream-key-2", "0-1", "1-1",
			}},
			want: XReadCommand{
				Streams: []XReadStream{
					XReadStream{
						streamKey: "stream-key-1",
						entryId: EntryId{
							MillisecondsTime: int64(0),
							SequenceNumber:   1,
						},
					},
					XReadStream{
						streamKey: "stream-key-2",
						entryId: EntryId{
							MillisecondsTime: int64(1),
							SequenceNumber:   1,
						},
					},
				},
			},
		},
		{
			// XREAD BLOCK 0 streams stream_key 0-1
			name: "XREAD read with block subcommand",
			input: Command{CommandType: "XREAD", CommandValues: []string{
				"BLOCK", "10", "STREAMS", "stream-key", "0-1",
			}},
			want: XReadCommand{
				BlockMillis: 10,
				Streams: []XReadStream{
					XReadStream{
						streamKey: "stream-key",
						entryId: EntryId{
							MillisecondsTime: int64(0),
							SequenceNumber:   1,
						},
					},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ans, err := parseXReadCommand(&tt.input)
			if err != nil {
				t.Errorf("ERROR result expected, but err got: %s", err.Error())
			}

			if !sameXReadCommandResults(&ans, &tt.want) {
				t.Errorf("ERROR got %v, want %v", ans, tt.want)
			}
		})
	}
}
