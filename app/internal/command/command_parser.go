package command

import (
	"bufio"
	"errors"
	"fmt"
	"math"
	"strconv"
	"strings"

	"github.com/codecrafters-io/redis-starter-go/app/internal/respparser"
	"github.com/codecrafters-io/redis-starter-go/app/internal/utils"
)

func parsePingCommand(_ *Command) (PingCommand, error) {
	return PingCommand{}, nil
}

func parseEchoCommand(command *Command) (EchoCommand, error) {
	if command.CommandType != "ECHO" {
		return EchoCommand{}, errors.New("Not an ECHO")
	}

	echoCommand := EchoCommand{
		Message: strings.Join(command.CommandValues, " "),
	}
	return echoCommand, nil
}

func parseGetCommand(command *Command) (GetCommand, error) {
	if command.CommandType != "GET" {
		return GetCommand{}, errors.New("Not a GET")
	} else if len(command.CommandValues) != 1 {
		return GetCommand{}, errors.New("GET must contains only one value (key)")
	}

	getCommand := GetCommand{
		Key: command.CommandValues[0],
	}
	return getCommand, nil
}

func parseSetCommand(command *Command) (SetCommand, error) {
	if len(command.CommandValues) < 2 {
		return SetCommand{}, errors.New("(SET cmd) too few arguments. At least key and value expected")
	}

	setCommand := SetCommand{
		RecordExpirationMillis: math.MaxInt32,
	}

	for n, arg := range command.CommandValues {
		if n == 0 {
			setCommand.Key = arg
			continue
		} else if n == 1 {
			setCommand.Value = arg
			continue
		} else {
			switch arg {
			case "PX":
				// millisecond expiry
				nextElem := n + 1
				if nextElem >= len(command.CommandValues) {
					errMsg := "(SET cmd) PX key expects value, but it seems to be missing!"
					utils.Log(errMsg)
					return SetCommand{}, errors.New(errMsg)
				}

				pxValue := command.CommandValues[nextElem]
				pxValueInt, err := strconv.Atoi(pxValue)
				if err != nil {
					errMsg := fmt.Sprintf("(SET cmd) PX value is expected to be int, but got %s", pxValue)
					utils.Log(errMsg)
					return SetCommand{}, errors.New(errMsg)
				}
				setCommand.RecordExpirationMillis = pxValueInt

			case "EX":
				// second expiry
				nextElem := n + 1
				if nextElem >= len(command.CommandValues) {
					errMsg := "(SET cmd) EX key expects value, but it seems to be missing!"
					utils.Log(errMsg)
					return SetCommand{}, errors.New(errMsg)
				}

				exValue := command.CommandValues[nextElem]
				exValueInt, err := strconv.Atoi(exValue)
				if err != nil {
					errMsg := fmt.Sprintf("(SET cmd) EX value is expected to be int, but got %s", exValue)
					utils.Log(errMsg)
					return SetCommand{}, errors.New(errMsg)
				}
				setCommand.RecordExpirationMillis = exValueInt * 1000 // from sec to millis
			default:
				continue
			}
		}
	}
	return setCommand, nil
}

func parseTypeCommand(command *Command) (TypeCommand, error) {
	if command.CommandType != "TYPE" {
		return TypeCommand{}, errors.New("Not a TYPE")
	} else if len(command.CommandValues) != 1 {
		return TypeCommand{}, errors.New("(TYPE cmd) must contains only one value (key)")
	}

	typeCommand := TypeCommand{
		Key: command.CommandValues[0],
	}
	return typeCommand, nil
}

func parseXAddCommand(command *Command) (XAddCommand, error) {
	if len(command.CommandValues) < 4 {
		return XAddCommand{}, errors.New("(XADD cmd) Too few arguments. At least stream-key, entry-id, akey and value expected")
	}

	xaddCommand := XAddCommand{}

	keys := []string{}
	values := []string{}

	for n, arg := range command.CommandValues {
		if n == 0 {
			xaddCommand.StreamKey = arg
			continue
		} else if n == 1 {
			entryId, err := parseXCommandsEntryId(arg)
			if err != nil {
				return XAddCommand{}, err
			}

			xaddCommand.EntryId = entryId
			continue

		} else {
			if n%2 == 0 {
				// keys
				keys = append(keys, arg)
			} else {
				// values
				values = append(values, arg)
			}
		}
	}

	if len(keys) != len(values) {
		return XAddCommand{}, errors.New("(XADD cmd) number of keys must be same as number of values!")
	}

	keyValues := make(map[string]string, len(keys))
	for i, k := range keys {
		keyValues[k] = values[i]
	}

	xaddCommand.FieldValues = keyValues
	return xaddCommand, nil
}

func parseXCommandsEntryId(entryIdString string) (EntryId, error) {
	entryId := EntryId{
		AutoGenerated: NoneAutoGeneratedEntryId,
	}

	if entryIdString == "*" {
		entryId.AutoGenerated = FullyGeneratedEntryId
		return entryId, nil
	}

	split := strings.Split(entryIdString, "-")
	// TODO split check
	if len(split) < 1 || len(split) > 2 {
		// explicit entry id
		errMsg := fmt.Sprintf("(parseXCommandsEntryId) EntryId required format '<millisecondsTime>' or '<millisecondsTime>-<sequenceNumber>', but got: %s", entryIdString)
		utils.Log(errMsg)
		return entryId, errors.New(errMsg)
	}

	var err error

	// Parse milliseconds time part
	entryIdMillisecondsTime := split[0]
	var millisecondsTime int64

	if entryIdMillisecondsTime == "*" {
		// autogenerated milliseconds time
		// This part is weird, don't think that something like *-1 is even supported by RESP
		entryId.AutoGenerated = PartiallyGeneratedEntryId
	} else {
		millisecondsTime, err = strconv.ParseInt(entryIdMillisecondsTime, 10, 64)
		if err != nil {
			errMsg := fmt.Sprintf("(parseXCommandsEntryId) EntryId millisecondsTime must be an integer, but got: %s", split[0])
			utils.Log(errMsg)
			return entryId, errors.New(errMsg)
		}
	}

	if len(split) == 1 {
		utils.Log(fmt.Sprintf("(parseXCommandsEntryId) Processing EntryId in format '<millisecondsTime>': %s", entryIdString))
		entryId.MillisecondsTime = millisecondsTime
		entryId.AutoGenerated = PartiallyGeneratedEntryId
		return entryId, nil
	} else {
		utils.Log(fmt.Sprintf("(parseXCommandsEntryId) Processing EntryId in format '<millisecondsTime>-<sequenceNumber>': %s", entryIdString))
		entryIdSequenceNumber := split[1]

		var sequenceNumber int
		if entryIdSequenceNumber == "*" {
			entryId.AutoGenerated = PartiallyGeneratedEntryId
		} else {
			sequenceNumber, err = strconv.Atoi(entryIdSequenceNumber)
			if err != nil {
				errMsg := fmt.Sprintf("(XADD cmd) EntryId sequenceNumber must be an integer, but got: %s", split[1])
				utils.Log(errMsg)
				return entryId, errors.New(errMsg)
			}
		}
		entryId.MillisecondsTime = millisecondsTime
		entryId.SequenceNumber = sequenceNumber
		return entryId, nil
	}
}

func parseXRangeCommand(command *Command) (XRangeCommand, error) {
	// XRANGE key start end [COUNT count]
	xRangeCommand := XRangeCommand{}
	if len(command.CommandValues) < 3 {
		return xRangeCommand, errors.New("(XADD cmd) Too few arguments. At least stream-key, start nillis and end millis expected")
	}

	xRangeCommand.StreamKey = command.CommandValues[0]

	startEntryIdString := command.CommandValues[1]

	//var startMillis, endMillis int64
	var startEntryId, endEntryId EntryId
	//var startSequenceNumber, endSequenceNumber int

	//var startEntryId, endEntryId EntryId
	var entryIdError error

	// - retrieve entries from the very beginning
	if startEntryIdString == "-" {
		startEntryId.MillisecondsTime = 0
		startEntryId.SequenceNumber = 0
	} else {
		//startMillis, startSequenceNumber, entryIdError = parseXCommandsEntryId(startEntryId)
		startEntryId, entryIdError = parseXCommandsEntryId(startEntryIdString)
		if entryIdError != nil {
			err := fmt.Errorf("ERROR (parseXrangeCommand) Can't decode start entry id %s: %e", startEntryIdString, entryIdError)
			utils.Log(err.Error())
			return xRangeCommand, err
		}
		// use default
		if startEntryId.SequenceNumber < 0 {
			startEntryId.SequenceNumber = 0
		}
	}

	xRangeCommand.StartEntryId = startEntryId

	endEntryIdString := command.CommandValues[2]
	// + entries from the given start ID to the end of the stream
	if endEntryIdString == "+" {
		endEntryId.MillisecondsTime = math.MaxInt64
		endEntryId.SequenceNumber = math.MaxInt
	} else {
		endEntryId, entryIdError = parseXCommandsEntryId(endEntryIdString)
		if entryIdError != nil {
			err := fmt.Errorf("ERROR (parseXrangeCommand) Can't decode end entry id %s: %e", endEntryIdString, entryIdError)
			utils.Log(err.Error())
			return xRangeCommand, err
		}
		// use default
		if endEntryId.SequenceNumber < 0 {
			endEntryId.SequenceNumber = 0
		}
	}
	xRangeCommand.EndEntryId = endEntryId

	return xRangeCommand, nil
}

func arrayToCommand(array respparser.Array) Command {
	if len(array.Items) == 0 {
		// TODO convert type to enum instead string
		// TODO return error instead PING
		return Command{
			CommandType:   "PING",
			CommandValues: nil,
		}
	} else if len(array.Items) == 1 {
		return Command{
			CommandType:   strings.ToUpper(array.Items[0].String()),
			CommandValues: nil,
		}
	} else {
		commandType := strings.ToUpper(array.Items[0].String())
		commandValues := make([]string, len(array.Items)-1)
		for n, content := range array.Items[1:] {
			commandValues[n] = content.String()
		}
		return Command{
			CommandType:   commandType,
			CommandValues: commandValues,
		}
	}
}

func GetCommandHandler(command *Command) (CommandHandler[string], error) {
	switch command.CommandType {
	case "PING":
		return parsePingCommand(command)
	case "ECHO":
		return parseEchoCommand(command)
	case "GET":
		return parseGetCommand(command)
	case "SET":
		return parseSetCommand(command)
	case "TYPE":
		return parseTypeCommand(command)
	case "XADD":
		return parseXAddCommand(command)
	case "XRANGE":
		return parseXRangeCommand(command)
	case "XREAD":
		return parseXReadCommand(command)
	default:
		return PingCommand{}, errors.ErrUnsupported
	}
}

func ParseCommand(r *bufio.Reader) (*Command, error) {
	// A client sends the Redis server an array consisting of only bulk strings.
	// command example *2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n
	arrayElements, err := respparser.DeserializeArray(r)
	if err != nil {
		return nil, err
	}

	command := arrayToCommand(arrayElements)
	return &command, nil
}
