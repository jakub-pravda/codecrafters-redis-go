package command

import (
	"bufio"
	"errors"
	"fmt"
	"math"
	"strconv"
	"strings"

	"github.com/codecrafters-io/redis-starter-go/app/internal/respparser"
	"github.com/codecrafters-io/redis-starter-go/app/internal/utils"
)

func parsePingCommand(_ *Command) (PingCommand, error) {
	return PingCommand{}, nil
}

func parseEchoCommand(command *Command) (EchoCommand, error) {
	if command.CommandType != "ECHO" {
		return EchoCommand{}, errors.New("Not an ECHO")
	}

	echoCommand := EchoCommand{
		Message: strings.Join(command.CommandValues, " "),
	}
	return echoCommand, nil
}

func parseGetCommand(command *Command) (GetCommand, error) {
	if command.CommandType != "GET" {
		return GetCommand{}, errors.New("Not a GET")
	} else if len(command.CommandValues) != 1 {
		return GetCommand{}, errors.New("GET must contains only one value (key)")
	}

	getCommand := GetCommand{
		Key: command.CommandValues[0],
	}
	return getCommand, nil
}

func parseSetCommand(command *Command) (SetCommand, error) {
	if len(command.CommandValues) < 2 {
		return SetCommand{}, errors.New("(SET cmd) too few arguments. At least key and value expected")
	}

	setCommand := SetCommand{
		RecordExpirationMillis: math.MaxInt32,
	}

	for n, arg := range command.CommandValues {
		if n == 0 {
			setCommand.Key = arg
			continue
		} else if n == 1 {
			setCommand.Value = arg
			continue
		} else {
			switch arg {
			case "PX":
				// millisecond expiry
				nextElem := n + 1
				if nextElem >= len(command.CommandValues) {
					errMsg := "(SET cmd) PX key expects value, but it seems to be missing!"
					utils.Log(errMsg)
					return SetCommand{}, errors.New(errMsg)
				}

				pxValue := command.CommandValues[nextElem]
				pxValueInt, err := strconv.Atoi(pxValue)
				if err != nil {
					errMsg := fmt.Sprintf("(SET cmd) PX value is expected to be int, but got %s", pxValue)
					utils.Log(errMsg)
					return SetCommand{}, errors.New(errMsg)
				}
				setCommand.RecordExpirationMillis = pxValueInt

			case "EX":
				// second expiry
				nextElem := n + 1
				if nextElem >= len(command.CommandValues) {
					errMsg := "(SET cmd) EX key expects value, but it seems to be missing!"
					utils.Log(errMsg)
					return SetCommand{}, errors.New(errMsg)
				}

				exValue := command.CommandValues[nextElem]
				exValueInt, err := strconv.Atoi(exValue)
				if err != nil {
					errMsg := fmt.Sprintf("(SET cmd) EX value is expected to be int, but got %s", exValue)
					utils.Log(errMsg)
					return SetCommand{}, errors.New(errMsg)
				}
				setCommand.RecordExpirationMillis = exValueInt * 1000 // from sec to millis
			default:
				continue
			}
		}
	}
	return setCommand, nil
}

func parseTypeCommand(command *Command) (TypeCommand, error) {
	if command.CommandType != "TYPE" {
		return TypeCommand{}, errors.New("Not a TYPE")
	} else if len(command.CommandValues) != 1 {
		return TypeCommand{}, errors.New("(TYPE cmd) must contains only one value (key)")
	}

	typeCommand := TypeCommand{
		Key: command.CommandValues[0],
	}
	return typeCommand, nil
}

func parseXaddCommand(command *Command) (XAddCommand, error) {
	if len(command.CommandValues) < 4 {
		return XAddCommand{}, errors.New("(XADD cmd) Too few arguments. At least stream-key, entry-id, akey and value expected")
	}

	xaddCommand := XAddCommand{}
	xaddCommand.AutoEntryId = NoneAutoGeneratedEntryId

	keys := []string{}
	values := []string{}

	for n, arg := range command.CommandValues {
		if n == 0 {
			xaddCommand.StreamKey = arg
			continue
		} else if n == 1 {
			millisecondsTime, sequenceNumber, err := parseXCommandsEntryId(arg)
			if err != nil {
				return XAddCommand{}, err
			}

			if sequenceNumber == -1 {
				xaddCommand.AutoEntryId = PartiallyGeneratedEntryId
			} else {
				xaddCommand.EntryIdSequenceNumber = sequenceNumber
			}

			if millisecondsTime == -1 {
				xaddCommand.AutoEntryId = FullyGeneratedEntryId
			} else {
				xaddCommand.EntryIdMillisecondsTime = millisecondsTime
			}

			continue

		} else {
			if n%2 == 0 {
				// keys
				keys = append(keys, arg)
			} else {
				// values
				values = append(values, arg)
			}
		}
	}

	if len(keys) != len(values) {
		return XAddCommand{}, errors.New("(XADD cmd) number of keys must be same as number of values!")
	}

	keyValues := make(map[string]string, len(keys))
	for i, k := range keys {
		keyValues[k] = values[i]
	}

	xaddCommand.FieldValues = keyValues
	return xaddCommand, nil
}

func parseXCommandsEntryId(entryId string) (int64, int, error) {
	millisNotFound := int64(-1)
	sequenceNumberNotFound := -1

	if entryId == "*" {
		// fully generated entry id
		return millisNotFound, sequenceNumberNotFound, nil
	}

	split := strings.Split(entryId, "-")
	// TODO split check
	if len(split) < 1 || len(split) > 2 {
		// explicit entry id
		errMsg := fmt.Sprintf("(parseXCommandsEntryId) EntryId required format '<millisecondsTime>' or '<millisecondsTime>-<sequenceNumber>', but got: %s", entryId)
		utils.Log(errMsg)
		return 0, 0, errors.New(errMsg)
	}

	var err error

	// Parse milliseconds time part
	entryIdMillisecondsTime := split[0]
	var millisecondsTime int64

	if entryIdMillisecondsTime == "*" {
		// autogenerated milliseconds time
		millisecondsTime = millisNotFound
	} else {
		millisecondsTime, err = strconv.ParseInt(entryIdMillisecondsTime, 10, 64)
		if err != nil {
			errMsg := fmt.Sprintf("(parseXCommandsEntryId) EntryId millisecondsTime must be an integer, but got: %s", split[0])
			utils.Log(errMsg)
			return 0, 0, errors.New(errMsg)
		}
	}

	if len(split) == 1 {
		utils.Log(fmt.Sprintf("(parseXCommandsEntryId) Processing EntryId in format '<millisecondsTime>': %s", entryId))
		return millisecondsTime, sequenceNumberNotFound, nil
	} else {
		utils.Log(fmt.Sprintf("(parseXCommandsEntryId) Processing EntryId in format '<millisecondsTime>-<sequenceNumber>': %s", entryId))
		entryIdSequenceNumber := split[1]

		var sequenceNumber int
		if entryIdSequenceNumber == "*" {
			// partially generated entry id
			sequenceNumber = sequenceNumberNotFound
		} else {
			sequenceNumber, err = strconv.Atoi(entryIdSequenceNumber)
			if err != nil {
				errMsg := fmt.Sprintf("(XADD cmd) EntryId sequenceNumber must be an integer, but got: %s", split[1])
				utils.Log(errMsg)
				return 0, 0, errors.New(errMsg)
			}
		}
		return millisecondsTime, sequenceNumber, nil
	}
}

func parseXrangeCommand(command *Command) (XRangeCommand, error) {
	// XRANGE key start end [COUNT count]
	xRangeCommand := XRangeCommand{}
	if len(command.CommandValues) < 3 {
		return xRangeCommand, errors.New("(XADD cmd) Too few arguments. At least stream-key, start nillis and end millis expected")
	}

	xRangeCommand.StreamKey = command.CommandValues[0]

	startEntryId := command.CommandValues[1]

	var startMillis, endMillis int64
	var startSequenceNumber, endSequenceNumber int
	var entryIdError error

	// - retrieve entries from the very beginning
	if startEntryId == "-" {
		startMillis = 0
		startSequenceNumber = 0
	} else {
		startMillis, startSequenceNumber, entryIdError = parseXCommandsEntryId(startEntryId)
		if entryIdError != nil {
			err := fmt.Errorf("(parseXrangeCommand) Can't decode start entry id %s: %e", startEntryId, entryIdError)
			utils.Log(err.Error())
			return xRangeCommand, err
		}
		// use default
		if startSequenceNumber < 0 {
			startSequenceNumber = 0
		}
	}

	xRangeCommand.StartMillisecondsTime = startMillis
	xRangeCommand.StartSequenceNumber = startSequenceNumber

	endEntryId := command.CommandValues[2]
	endMillis, endSequenceNumber, entryIdError = parseXCommandsEntryId(endEntryId)
	if entryIdError != nil {
		err := fmt.Errorf("(parseXrangeCommand) Can't decode end entry id %s: %e", endEntryId, entryIdError)
		utils.Log(err.Error())
		return xRangeCommand, err
	}
	// use default
	if endSequenceNumber < 0 {
		endSequenceNumber = 0
	}
	xRangeCommand.EndMillisecondsTime = endMillis
	xRangeCommand.EndSequenceNumber = endSequenceNumber

	return xRangeCommand, nil
}

func arrayToCommand(array respparser.Array) Command {
	if len(array.Items) == 0 {
		// TODO return error instead PING
		return Command{
			CommandType:   "PING",
			CommandValues: nil,
		}
	} else if len(array.Items) == 1 {
		return Command{
			CommandType:   array.Items[0].String(),
			CommandValues: nil,
		}
	} else {
		commandType := array.Items[0].String()
		commandValues := make([]string, 0)
		for _, content := range array.Items[1:] {
			commandValues = append(commandValues, content.String())
		}
		return Command{
			CommandType:   commandType,
			CommandValues: commandValues,
		}
	}
}

func GetCommandHandler(command *Command) (CommandHandler[string], error) {
	switch strings.ToUpper(command.CommandType) {
	case "PING":
		return parsePingCommand(command)
	case "ECHO":
		return parseEchoCommand(command)
	case "GET":
		return parseGetCommand(command)
	case "SET":
		return parseSetCommand(command)
	case "TYPE":
		return parseTypeCommand(command)
	case "XADD":
		return parseXaddCommand(command)
	case "XRANGE":
		return parseXrangeCommand(command)
	default:
		return PingCommand{}, errors.ErrUnsupported
	}
}

func ParseCommand(r *bufio.Reader) (*Command, error) {
	// A client sends the Redis server an array consisting of only bulk strings.
	// command example *2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n
	arrayElements, error := respparser.DeserializeArray(r)
	if error != nil {
		return nil, error
	}

	command := arrayToCommand(arrayElements)
	return &command, nil
}
